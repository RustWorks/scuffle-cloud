use std::collections::{HashMap, HashSet};

use anyhow::Context;
use cargo_metadata::camino::Utf8Path;

use super::util::{Fragment, PackageChangeLog};
use crate::cmd::IGNORED_PACKAGES;

#[derive(Debug, Clone, clap::Parser)]
pub struct Generate {
    #[clap(long, short, value_delimiter = ',')]
    #[clap(alias = "package")]
    /// Packages to test
    packages: Vec<String>,
    #[clap(long, short, value_delimiter = ',')]
    #[clap(alias = "exclude-package")]
    /// Packages to exclude from testing
    exclude_packages: Vec<String>,
}

const CHANGE_LOG_HEADER: &str = "# Changelog

<!--
This file is automatically generated by our release process.
DO NOT edit it directly.
If you want to add a change log entry for this package,
please create a new file in /changes.d/<pr-number>.toml
Refer to the [README.md](/changes.d/README.md) for more information.
-->

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
";

fn update_change_log(logs: &[PackageChangeLog], manifest_path: &Utf8Path) -> anyhow::Result<()> {
    let change_log_path_md = manifest_path.with_file_name("CHANGELOG.md");

    let mut change_log = if !change_log_path_md.exists() {
        CHANGE_LOG_HEADER.to_string()
    } else {
        std::fs::read_to_string(&change_log_path_md).context("failed to read CHANGELOG.md")?
    };

    // Find the # [Unreleased] section
    // So we can insert the new logs after it
    let mut breaking_changes = logs.iter().filter(|log| log.breaking).collect::<Vec<_>>();
    breaking_changes.sort_by_key(|log| &log.category);
    let mut other_changes = logs.iter().filter(|log| !log.breaking).collect::<Vec<_>>();
    other_changes.sort_by_key(|log| &log.category);

    fn make_logs(logs: &[&PackageChangeLog]) -> String {
        logs.iter()
            .map(
                |entry| {
                    format!(
                        "- {category}: {description} ([#{pr_number}](https://github.com/scufflecloud/scuffle/pull/{pr_number})){authors}",
                        category = entry.category,
                        description = entry.description,
                        pr_number = entry.pr_number,
                        authors = if !entry.authors.is_empty() {
                            format!(" ({})", entry.authors.join(", "))
                        } else {
                            String::new()
                        },
                    )
                 }
            )
            .collect::<Vec<_>>()
            .join("\n")
    }

    let breaking_changes = make_logs(&breaking_changes);
    let other_changes = make_logs(&other_changes);

    let mut replaced = String::new();

    replaced.push_str("## [Unreleased]\n");
    if !breaking_changes.is_empty() {
        replaced.push_str("\n### ‚ö†Ô∏è Breaking changes\n\n");
        replaced.push_str(&breaking_changes);
        replaced.push('\n');
    }

    if !other_changes.is_empty() {
        replaced.push_str("\n### üõ†Ô∏è Non-breaking changes\n\n");
        replaced.push_str(&other_changes);
        replaced.push('\n');
    }

    change_log = change_log.replace("## [Unreleased]\n", &replaced);

    std::fs::write(&change_log_path_md, change_log).context("failed to write CHANGELOG.md")?;

    Ok(())
}

fn generate_change_logs(
    package: &str,
    change_fragments: &mut HashMap<u64, Fragment>,
) -> anyhow::Result<Vec<PackageChangeLog>> {
    let mut logs = Vec::new();

    for fragment in change_fragments.values_mut() {
        logs.extend(fragment.remove_package(package).context("parse")?);
    }

    Ok(logs)
}

fn save_change_fragments(fragments: &mut HashMap<u64, Fragment>) -> anyhow::Result<()> {
    fragments
        .values_mut()
        .filter(|fragment| fragment.changed)
        .try_for_each(|fragment| fragment.save().context("save"))?;

    fragments.retain(|_, fragment| !fragment.deleted);

    Ok(())
}

impl Generate {
    pub fn run(self) -> anyhow::Result<()> {
        let start = std::time::Instant::now();

        let metadata = crate::utils::metadata()?;

        let workspace_package_ids = metadata.workspace_members.iter().cloned().collect::<HashSet<_>>();

        let path = metadata.workspace_root.join("changes.d");

        eprintln!("reading {path}");

        let mut change_fragments = std::fs::read_dir(&path)?
            .filter_map(|entry| entry.ok())
            .filter_map(|entry| {
                let path = entry.path();
                if path.is_file() {
                    let pr_number = path
                        .file_name()?
                        .to_str()?
                        .strip_prefix("pr-")?
                        .strip_suffix(".toml")?
                        .parse()
                        .ok()?;

                    Some((pr_number, path))
                } else {
                    None
                }
            })
            .try_fold(HashMap::new(), |mut fragments, (pr_number, path)| {
                let fragment = Fragment::new(pr_number, &path).with_context(|| path.display().to_string())?;

                fragments.insert(pr_number, fragment);

                anyhow::Ok(fragments)
            })?;

        let packages = metadata
            .packages
            .iter()
            .filter(|p| workspace_package_ids.contains(&p.id) && !IGNORED_PACKAGES.contains(&p.name.as_str()))
            .filter(|p| self.packages.is_empty() || self.packages.contains(&p.name))
            .filter(|p| self.exclude_packages.is_empty() || !self.exclude_packages.contains(&p.name))
            .collect::<Vec<_>>();

        for package in &self.packages {
            anyhow::ensure!(packages.iter().any(|p| p.name == *package), "Package {} not found", package);
        }

        for package in packages {
            let change_logs = generate_change_logs(package.name.as_str(), &mut change_fragments).context("generate")?;
            if !change_logs.is_empty() {
                update_change_log(&change_logs, &package.manifest_path).context("update")?;
                save_change_fragments(&mut change_fragments).context("save")?;
                eprintln!("Updated change logs for {}", package.name);
            }
        }

        eprintln!("Done in {:?}", start.elapsed());

        Ok(())
    }
}
